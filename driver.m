function exitflag = driver(controlsFilePath)
%DRIVER setups up and runs the Inverse Micro-Scale Atmospheric 
% Dispersion Model to find the optimum volumetric source to profile 
% to recreate synthetic receptor observations from a known source
%
% Last Modified:
%   March 04, 2013 by Ian Joynes
%
% PROCEDURE
%   This function reads a control file which gives the values of the 
%   Inverse Micro-Scale Atmospheric Dispersion Model parameters which 
%   include: simDir, operDir, tMax, noise, maxIter, regpar, factr, 
%   pgtol, m and iprint.  The function then loads the 2D unstructured 
%   triangular mesh, the location of the receptors and the location 
%   and emission rate of the known sources.  The concentration of the 
%   methane released from the known sources is determined by 
%   numerically solving the advection-diffusion equation.  The 
%   synthetic receptor observation are extracted from the 
%   concentration field.  With the synthetic receptor observations, 
%   source reconstruction begins by calling the general lbfgs driver.
%   This function iteratively improves the fitness of candidate 
%   volumetric emission source profiles by minimizing an objective 
%   function based on the misfit between the synthetic receptor 
%   observations and the modelled observations from a candidate 
%   volumetric emission source profile.
%
% REQUIRED FILES
%
% INPUTS
%
%
% VARIABLES
%   simDir    Directory path the the simulation results.
%   operDir   Directory path the stiffness and capacitance matricies.
%   tMax      The max time of the simulation.
%   noise     The slope of the line which relates the observation 
%               concentration to the standard deviation of the 
%               gaussian distributed noise (0.1 = 10% noise).
%   maxIter   Maximum number of iterations.
%   reg_par   Regularization parameter (reg_par >= 0).
%   signal_o  Matrix representing the synthetic receptor observations
%               each row represents a sample time, and each column 
%               represents an idividual receptor.  Measurements are 
%               reported in the units kg/m^3.
%   signal_c  Matrix representing the receptor observations for a 
%               candidate volumetric source profile each row 
%               represents a sample time, and each column represents 
%               an idividual receptor.  Measurements are reported in 
%                the units kg/m^3.
%   spaceIntWeight  A weight matrix for the regularization term of the 
%                     objective function.  This weight matrix 
%                     penalizes emission rates from larger elements 
%                     more than smaller elements.
%   m_star    The total emission rate of the known source in kg/s.


% Declare the global variables. 
% The LBFGS function does not allow for additional variables to be 
% passed to the objective function (or any other function the 
% objective function may call).  Critical variables which are 
% determined before the objective function is called are declared as 
% global variables.
global simDir operDir tMax noise reg_par signal_o signal_c ...
        spaceIntWeight m_star

% Write the simulation start date and time to the log file.
fprintf('%s\n', datestr(now) );

% Set the control file to read only.
fileattrib(controlsFilePath,'-w'); 

% Read the run parameters from the  control file and write their 
% values to the log file.
[simDir,operDir,tMax, noise,maxIter, ...
reg_par, factr,pgtol,m,iprint] = readControls(controlsFilePath)

% Declare the file paths the critical simulation files
domainPath = fullfile(simDir,'Domain.mat');
paramPath = fullfile(simDir,'Parameters.mat');
sensorPath = fullfile(simDir,'Sensors.mat');
sourcePath = fullfile(simDir,'Source.mat');
passPath = fullfile(simDir,'pass.mat');

% Save these file paths for later reference
save(fullfile(simDir,'dirSettings.mat'), 'domainPath','paramPath', ...
  'sensorPath','sourcePath','passPath');

% Make directories to store data generated by the atmospheric 
% transport model, its adjoint and the LBFGS.
mkdir(fullfile(simDir,'Source'));
mkdir(fullfile(simDir,'Concentration'));
mkdir(fullfile(simDir,'Observation'));
mkdir(fullfile(simDir,'Concentration_Initial_Guess'));
mkdir(fullfile(simDir,'Adjoint'));
mkdir(fullfile(simDir,'Gradient'));
mkdir(fullfile(simDir,'Noise'));

% Load the mesh, sensor placement and emission source details
load(domainPath);
load(sensorPath);
load(sourcePath);

% Construct the 
spaceIntWeight = zeros(nNodes,1);
for i = 1 : nTris
  spaceIntWeight(tri(i,:)) = spaceIntWeight(tri(i,:)) + det([ones(3,1) xy(tri(i,:),:) ] );
end
spaceIntWeight = spaceIntWeight/6;
% ----------------------------------------------------------------------------

% Move sensors to the closest mesh nodes
sensorIndex = placeSensors(xy, receptor_xy);

% Determine discrete representation of the emission source
E = placeSources(tri, xy, source_xy, source_m);
m_star = dot(spaceIntWeight,E);
save(sensorPath, 'sensorIndex', '-append')

% Re
xy = xy - ones(nNodes,1)*min(xy);
dt = 1;
t = (0:dt:tMax)';


nt = length(t);

c_0 = zeros(nNodes,1);

% -----------------------------------------------------------------------------
if exist(fullfile(simDir,'Source','Source_0.mat'))==2
  load(fullfile(simDir,'Source','Source_0.mat'),'s');
  E_0 = s;
else
  E_0 = zeros(nNodes,1);
  s = E_0;
  save(fullfile(simDir,'Source','Source_0.mat'),'s');
end

save(fullfile(simDir, 'Source', 'Source_Correct.mat'), 'E','m_star');

SolveConcentrationTransport(t,E,c_0,'o',noise);
signal_o=nan(nt,length(sensorIndex));
signal_c=nan(nt,length(sensorIndex));
for i = 1 : nt
  load(fullfile(simDir, 'Observation', ['Observation_' int2str(i-1) '.mat']),'o')
  if noise > 0
  load(fullfile(simDir, 'Noise', ['Noise_' int2str(i-1) '.mat']), 'o_error')
  signal_o(i,:) = o(sensorIndex) + o_error(sensorIndex);

  else
  signal_o(i,:) = o(sensorIndex);
end
end

save(fullfile(simDir,'Source','Source_Correct.mat'), 'E','signal_o');

save(paramPath,'t', 'c_0', 'boundary', 'sensorIndex','nNodes', 'nt','tri','xy','E')

nPass = 0;
save(passPath,'nPass');

fn = @objective;
x0 = E_0;
lb = zeros(nNodes,1);
ub = Inf*ones(nNodes,1);
nbd = ones(nNodes,1);

opts = lbfgs_options('iprint', iprint, ...
                     'maxits', maxIter, ...
                     'factr', factr, ...
                     'pgtol', pgtol, ...
                     'm', m, ...
                     'cb', @test_callback);
           

[x,fx,exitflag,userdata] = lbfgs(fn,x0, lb, ub, nbd, opts);


save(fullfile(simDir,'Source','Optimum_Source.mat'),'x','fx');
save(fullfile(simDir,'exit_dump.mat'));
fprintf('Done: %s\n', datestr(now));
